<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>VotingSim Client Demo (1D/2D)</title>
<style>
  :root{
    --gap: 16px;
    --panel-bg: #fafafa;
    --border: #d6d6d6;
    --text: #111;
  }
  body { font-family: Arial, sans-serif; margin: 12px; font-size: 16px; color: var(--text); }
  h2 { margin: 0 0 8px 0; }
  p { margin: 6px 0 12px 0; line-height: 1.35; }

  /* Responsive app layout */
  .app { display:flex; gap: var(--gap); align-items:flex-start; flex-wrap: wrap; }
  .panel { background: var(--panel-bg); border:1px solid var(--border); border-radius:12px; padding: 12px; }
  .controls { flex: 1 1 340px; min-width: 320px; max-width: 520px; }
  .viz { flex: 2 1 420px; min-width: 320px; }

  .grid { display:grid; grid-template-columns: 170px 1fr; gap: 10px 12px; align-items:center; }
  label { font-size: 14px; color:#222; }
  input, select { font-size: 16px; padding: 10px 10px; border:1px solid #bbb; border-radius:10px; width: 100%; box-sizing: border-box; }
  input[type="number"] { max-width: 220px; }

  .buttons { display:flex; gap: 10px; flex-wrap: wrap; margin-top: 12px; }
  button { padding: 12px 14px; font-size: 16px; border-radius:12px; border:1px solid #888; background:#fff; cursor:pointer; }
  button:hover { background:#f0f0f0; }

  .hint { font-size: 13px; color:#555; margin-top: 8px; }
  pre { background:#111; color:#eee; padding:10px; border-radius:10px; overflow:auto; max-height:180px; font-size: 13px; }

  /* 2D canvas container */
  #canvasWrap { aspect-ratio: 4 / 3; border:1px solid #ccc; border-radius:12px; width:100%; height: min(60vh, 420px); overflow:hidden; background:#fff; }
  canvas { width:100%; height:100%; display:block; }

  /* 3D container */
  #vis3dWrap { border:1px solid #ccc; border-radius:12px; width:100%; height: min(60vh, 420px); overflow:hidden; background:#fff; }
  #vis3d { width:100%; height:100%; }

  /* QR */
  #qr { width:140px; height:140px; }
  #shareUrl { width: 100%; }

  /* Smaller screens */
  @media (max-width: 600px) {
    body { margin: 10px; }
    .grid { grid-template-columns: 1fr; }
    input[type="number"] { max-width: none; }
    #qr { width:120px; height:120px; }
  }
</style>
</head>
<body>

<h2>VotingSim — Browser demo (client-side)</h2>
<p>Scan or load a URL with an encoded config, or adjust controls and press Run. The demo visualizes 1D and 2D quickly.</p>

<div class="app">
  <div class="panel controls">
    <h3 style="margin:0 0 10px 0;">Simulation Controls</h3>
    <div class="row">
      <label>Config URL / ?c=...</label>
    </div>

    <div class="col">
      <div class="row">
        <label>Dim</label>
        <select id="dim"><option value="1">1</option><option value="2" selected>2</option><option value="3">3</option></select>
        <label>Voters</label><input id="voters" type="number" value="500" min="1" max="10000" />
        <label>Candidates</label><input id="candidates" type="number" value="5" min="1" max="200" />
      </div>

      <div class="row">
        <label>Layout</label>
        <select id="layout"><option value="control">control</option><option value="random">random</option></select>
        <label>min-cand-dist</label><input id="mincand" type="number" step="0.01" value="0.3" />
        <label>noise-sigma</label><input id="noise" type="number" step="0.001" value="0.0" />
      </div>

      <div class="row">
        <label>Method</label>
        <select id="method"><option value="both" selected>both</option><option value="plurality">plurality</option><option value="approval">approval</option></select>
        <button id="encodeBtn">Encode URL & QR</button>
        <button id="runBtn">Run</button>
        <button id="downloadCsvBtn">Download CSV</button>
      </div>

      <div class="row" style="gap:8px; align-items:flex-start;">
        <div id="qr"></div>
        <div>
          <div><strong>Share URL</strong></div>
          <input id="shareUrl" style="width:320px;" readonly />
        </div>
      </div>

      <div style="margin-top:12px;">
        <strong>Console / Summary</strong>
        <pre id="log">Ready.</pre>
      </div>
    </div>
  </div>

  <div class="panel viz">
    <h3 style="margin:0 0 10px 0;">Visualization</h3>
    <div id="canvasWrap">
      <canvas id="vis" width="860" height="420"></canvas>
    </div>
    <div id="vis3dWrap" style="display:none;">
      <div id="vis3d"></div>
    </div>
    <div style="margin-top:8px;">
      <small>Visualization: for 1D shows candidates as C0..Ck-1 and voters as dots (color = plurality winner). For 2D shows scatter.</small>
    </div>
  </div>
</div>

<!-- QR generation library (small) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
/*
  Minimal client-side port of the simulator:
  - Supports dim 1/2/3
  - Candidates: control (grid) or random with min separation (rejection sampling)
  - Voters uniform in [-1,1]^dim, gaussian noise added per coordinate (clamped)
  - Methods: plurality and approval (tv = min-cand-dist)
  - Outputs internal CSV for download
*/

function base64urlEncode(str) {
  // encode UTF-8 then base64url
  const b64 = btoa(unescape(encodeURIComponent(str)));
  return b64.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}
function base64urlDecode(s) {
  s = s.replace(/-/g,'+').replace(/_/g,'/');
  // pad
  while (s.length % 4) s += '=';
  try {
    return decodeURIComponent(escape(atob(s)));
  } catch(e) { return null; }
}

function nowStamp() {
  const d = new Date();
  const pad=(n,l=2)=>String(n).padStart(l,'0');
  return d.getFullYear()+pad(d.getMonth()+1)+pad(d.getDate())+'_'+pad(d.getHours())+pad(d.getMinutes())+pad(d.getSeconds());
}

function randNorm(mean, sigma) {
  // Box-Muller
  let u = 0, v = 0;
  while(u === 0) u = Math.random();
  while(v === 0) v = Math.random();
  const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0*Math.PI*v);
  return mean + z * sigma;
}

function clamp(x, lo, hi) { return Math.max(lo, Math.min(hi, x)); }

function dmaxForDim(dim) {
  if (dim===1) return 2.0;
  if (dim===2) return 2.0*Math.sqrt(2.0);
  return 2.0*Math.sqrt(3.0);
}

function dist(a,b,dim) {
  let s=0;
  for (let i=0;i<dim;i++){ const d=a[i]-b[i]; s += d*d; }
  return Math.sqrt(s);
}

function sampleUniform(dim) {
  const p = [0,0,0];
  for (let i=0;i<dim;i++) p[i] = (Math.random()*2.0 - 1.0);
  return p;
}

function addNoiseClamp(pt, dim, sigma) {
  if (sigma <= 0) return pt.slice(0,3);
  const out = pt.slice(0,3);
  for (let i=0;i<dim;i++) {
    out[i] = clamp(out[i] + randNorm(0, sigma), -1.0, 1.0);
  }
  return out;
}

// candidate generators
function generateControl(dim,K) {
  const c = [];
  if (dim===1) {
    if (K===1) return [[0,0,0]];
    for (let i=0;i<K;i++){
      const t = i/(K-1);
      c.push([ -1 + 2*t, 0, 0 ]);
    }
    return c;
  }
  if (dim===2) {
    const nx = Math.ceil(Math.sqrt(K));
    const ny = Math.ceil(K/nx);
    const coord = (idx,n)=> n<=1 ? 0 : (-1 + 2*(idx/(n-1)));
    for (let j=0;j<ny && c.length<K;j++){
      for (let i=0;i<nx && c.length<K;i++){
        c.push([ coord(i,nx), coord(j,ny), 0 ]);
      }
    }
    return c;
  }
  // dim 3
  const n = Math.max(1, Math.ceil(Math.cbrt(K)));
  const coord = (idx,n)=> n<=1 ? 0 : (-1 + 2*(idx/(n-1)));
  for (let kk=0; kk<n && c.length<K; kk++){
    for (let jj=0; jj<n && c.length<K; jj++){
      for (let ii=0; ii<n && c.length<K; ii++){
        c.push([coord(ii,n), coord(jj,n), coord(kk,n)]);
      }
    }
  }
  return c;
}

function generateRandomMinsep(dim,K,minDist) {
  const c = [];
  const maxAttempts = 200000;
  let attempts=0;
  if (minDist<=0) {
    for (let i=0;i<K;i++) c.push(sampleUniform(dim));
    return c;
  }
  while (c.length < K) {
    if (++attempts > maxAttempts) throw new Error("Failed to place candidates with min separation. Reduce min or candidates.");
    const p = sampleUniform(dim);
    let ok=true;
    for (const q of c) {
      if (dist(p,q,dim) < minDist) { ok=false; break; }
    }
    if (ok) c.push(p);
  }
  return c;
}

// main simulator (single-run)
function runSimulation(cfg) {
  const dim = cfg.d;
  const N = cfg.v;
  const K = cfg.k;
  const layout = cfg.l;
  const mincand = cfg.min;
  const sigma = cfg.s;
  const method = cfg.m;

  // NOTE: The browser demo is interactive. If you allow very large N*K it can feel slow.
  // You can optionally cap N here for dim=3 if desired, but we keep full N by default.

  const candidates = (layout==='control') ? generateControl(dim, K) : generateRandomMinsep(dim, K, mincand);

  // Precompute constants
  const dmax = dmaxForDim(dim);
  const tv2 = mincand * mincand;
  const eps2 = 1e-24; // for squared-distance tie detection

  // Per-candidate tallies (computed in one pass)
  const pluralityVotes = new Array(K).fill(0);
  const pluralityUtilSums = new Array(K).fill(0);
  const pluralityUtilWs = new Array(K).fill(0);

  const approvalVotes = new Array(K).fill(0);
  let totalApprovals = 0;
  let turnout = 0;

  const approvalUtilSums = new Array(K).fill(0);
  const approvalUtilCounts = new Array(K).fill(0);

  // Generate voters and compute per-voter + tallies in one pass
  const voters = new Array(N);
  for (let i=0;i<N;i++){
    const base = sampleUniform(dim);
    const pos = addNoiseClamp(base, dim, sigma);

    // Find nearest candidate(s), and approvals.
    let best2 = Infinity;
    let bestIds = [];
    let bestApproved2 = Infinity;
    let bestApprovedId = -1;
    let approvalCount = 0;

    // We'll also keep a small list of approved candidate ids only when needed for per-candidate approval votes.
    // But since K is usually small, we just update approvalVotes on the fly.
    for (let ci=0; ci<K; ci++){
      const dx = pos[0] - candidates[ci][0];
      const dy = (dim>=2) ? (pos[1] - candidates[ci][1]) : 0;
      const dz = (dim>=3) ? (pos[2] - candidates[ci][2]) : 0;
      const d2 = dx*dx + dy*dy + dz*dz;

      // nearest (tie aware)
      if (d2 + eps2 < best2) {
        best2 = d2;
        bestIds = [ci];
      } else if (Math.abs(d2 - best2) <= eps2) {
        bestIds.push(ci);
      }

      // approval
      if (d2 <= tv2 + eps2) {
        approvalVotes[ci] += 1;
        totalApprovals += 1;
        approvalCount += 1;

        if (d2 < bestApproved2) {
          bestApproved2 = d2;
          bestApprovedId = ci;
        }
      }
    }

    const bestDist = Math.sqrt(best2);
    const pluralityUtility = Math.max(0, 1 - (bestDist / dmax));

    // fractional plurality votes for ties
    const w = 1.0 / bestIds.length;
    for (const ci of bestIds) {
      pluralityVotes[ci] += w;
      pluralityUtilSums[ci] += pluralityUtility * w;
      pluralityUtilWs[ci] += w;
    }

    // plurality_choice is -1 on tie, else the winner id
    const pluralityChoice = (bestIds.length===1) ? bestIds[0] : -1;

    // approval per-voter fields
    let votedApproval = 0;
    let approvalNearest = -1;
    let approvalNearestDist = 0;
    let approvalUtility = 0;

    if (approvalCount > 0) {
      votedApproval = 1;
      turnout += 1;
      approvalNearest = bestApprovedId;
      approvalNearestDist = Math.sqrt(bestApproved2);
      approvalUtility = Math.max(0, 1 - (approvalNearestDist / dmax));

      // attribute utility to nearest approved candidate
      approvalUtilSums[approvalNearest] += approvalUtility;
      approvalUtilCounts[approvalNearest] += 1;
    }

    voters[i] = {
      id: i,
      pos: pos,
      threshold: mincand,
      plurality_choice: pluralityChoice,
      plurality_dist: bestDist,
      plurality_utility: pluralityUtility,
      approval_count: approvalCount,
      approval_nearest: approvalNearest,
      approval_nearest_dist: approvalNearestDist,
      approval_utility: approvalUtility,
      voted_approval: votedApproval
    };
  }

  // Plurality summary
  const pluralityShares = pluralityVotes.map(v=> v / N);
  const pluralityAvgUtilByCandidate = pluralityUtilSums.map((s,i)=> (pluralityUtilWs[i]>0 ? s / pluralityUtilWs[i] : 0));
  const pluralityAvgUtilOverall = voters.reduce((a,b)=> a + b.plurality_utility, 0) / N;
  const maxPlurality = Math.max(...pluralityVotes);
  const pluralityWinners = pluralityVotes.map((v,i)=> Math.abs(v-maxPlurality) <= 1e-9 ? i : -1).filter(x=> x>=0);
  const pluralityTie = (pluralityWinners.length >= 2) ? 1 : 0;
  const pluralityWinner = (pluralityWinners.length >= 1) ? pluralityWinners[0] : -1;

  // Approval summary
  const approvalSharesOfVoters = approvalVotes.map(v=> v / N);
  const approvalSharesOfApprovals = approvalVotes.map(v=> totalApprovals>0 ? v / totalApprovals : 0);
  const approvalAvgUtilByCandidate = approvalUtilSums.map((s,i)=> approvalUtilCounts[i]>0 ? s/approvalUtilCounts[i] : 0);
  const approvalAvgUtilOverall = voters.reduce((a,b)=> a + b.approval_utility, 0) / N;
  const maxApproval = Math.max(...approvalVotes);
  const approvalWinners = approvalVotes.map((v,i)=> Math.abs(v-maxApproval) <= 1e-9 ? i : -1).filter(x=> x>=0);
  const approvalTie = (approvalWinners.length >= 2) ? 1 : 0;
  const approvalWinner = (approvalWinners.length >= 1) ? approvalWinners[0] : -1;

  return {
    cfg, candidates, voters,
    plurality: {
      votes: pluralityVotes, shares: pluralityShares, avgUtilByCandidate: pluralityAvgUtilByCandidate,
      avgUtilOverall: pluralityAvgUtilOverall, winner: pluralityWinner, tie: pluralityTie
    },
    approval: {
      votes: approvalVotes, sharesOfVoters: approvalSharesOfVoters, sharesOfApprovals: approvalSharesOfApprovals,
      avgUtilByCandidate: approvalAvgUtilByCandidate, avgUtilOverall: approvalAvgUtilOverall,
      winner: approvalWinner, tie: approvalTie, turnout, abstained: N - turnout, totalApprovals
    }
  };
}

// CSV generation for voter rows (one-run)
function makeCsvForRun(result) {
  const cfg = result.cfg;
  const dim = cfg.d;
  const header = ['voter_id'];
  if (dim>=1) header.push('x');
  if (dim>=2) header.push('y');
  if (dim>=3) header.push('z');
  header.push('threshold_tv','plurality_choice','plurality_dist','plurality_utility','approval_count',
              'approval_nearest','approval_nearest_dist','approval_utility','voted_approval');
  const rows = [ header.join(',') ];
  for (const v of result.voters) {
    const r = [v.id];
    if (dim>=1) r.push(v.pos[0].toFixed(6));
    if (dim>=2) r.push(v.pos[1].toFixed(6));
    if (dim>=3) r.push(v.pos[2].toFixed(6));
    r.push(v.threshold.toFixed(6), v.plurality_choice, v.plurality_dist.toFixed(6),
           v.plurality_utility.toFixed(6), v.approval_count, v.approval_nearest,
           v.approval_nearest_dist.toFixed(6), v.approval_utility.toFixed(6), v.voted_approval);
    rows.push(r.join(','));
  }
  return rows.join('\n');
}

// --- UI wiring and visualization ---

const qs = (id)=>document.getElementById(id);
const canvas = qs('vis');
const ctx = canvas.getContext('2d');
function resize2DCanvas() {
  const wrap = document.getElementById('canvasWrap');
  const cssW = Math.max(1, wrap.clientWidth);
  const cssH = Math.max(1, wrap.clientHeight);
  const dpr = Math.min(window.devicePixelRatio || 1, 2);

  canvas.width  = Math.floor(cssW * dpr);
  canvas.height = Math.floor(cssH * dpr);

  // Draw in CSS pixel coordinates.
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener('resize', resize2DCanvas);


// --- 3D (Three.js) state ---
// Interactive view for dim=3: drag to rotate, pinch/scroll to zoom.
// We create the WebGL scene lazily so 1D/2D stay lightweight.
let g3d = {
  inited: false,
  container: null,
  renderer: null,
  scene: null,
  camera: null,
  controls: null,
  votersPts: null,
  candPts: null,
  animHandle: 0
};

// Minimal orbit controls (no external OrbitControls dependency).
// Drag to rotate, wheel/pinch (trackpad) to zoom.
// Keeps the code portable for GitHub Pages and avoids CDN module quirks.
class SimpleOrbitControls {
  constructor(camera, domElement) {
    this.camera = camera;
    this.domElement = domElement;
    this.target = new THREE.Vector3(0,0,0);

    // Spherical coordinates
    const offset = new THREE.Vector3().copy(camera.position).sub(this.target);
    this.radius = offset.length();
    this.theta = Math.atan2(offset.x, offset.z); // around Y
    this.phi = Math.acos(Math.min(1, Math.max(-1, offset.y / Math.max(1e-9, this.radius)))); // from +Y

    this.rotateSpeed = 0.006;
    this.zoomSpeed = 0.0012;

    this.minRadius = 0.6;
    this.maxRadius = 12.0;

    this._dragging = false;
    this._lastX = 0;
    this._lastY = 0;

    // Bind handlers
    this._onDown = (e)=>this._pointerDown(e);
    this._onMove = (e)=>this._pointerMove(e);
    this._onUp = (e)=>this._pointerUp(e);
    this._onWheel = (e)=>this._wheel(e);

    domElement.addEventListener('pointerdown', this._onDown);
    window.addEventListener('pointermove', this._onMove);
    window.addEventListener('pointerup', this._onUp);
    domElement.addEventListener('wheel', this._onWheel, { passive:false });

    // Touch-action helps mobile dragging
    domElement.style.touchAction = 'none';
  }

  dispose() {
    this.domElement.removeEventListener('pointerdown', this._onDown);
    window.removeEventListener('pointermove', this._onMove);
    window.removeEventListener('pointerup', this._onUp);
    this.domElement.removeEventListener('wheel', this._onWheel);
  }

  _pointerDown(e) {
    this._dragging = true;
    this._lastX = e.clientX;
    this._lastY = e.clientY;
    try { this.domElement.setPointerCapture(e.pointerId); } catch(_) {}
  }

  _pointerMove(e) {
    if (!this._dragging) return;
    const dx = e.clientX - this._lastX;
    const dy = e.clientY - this._lastY;
    this._lastX = e.clientX;
    this._lastY = e.clientY;

    this.theta -= dx * this.rotateSpeed;
    this.phi   -= dy * this.rotateSpeed;

    // Clamp phi away from poles
    const eps = 0.02;
    this.phi = Math.max(eps, Math.min(Math.PI - eps, this.phi));
  }

  _pointerUp(e) {
    this._dragging = false;
  }

  _wheel(e) {
    e.preventDefault();
    // deltaY > 0 zoom out, < 0 zoom in
    const zoomFactor = 1.0 + (e.deltaY * this.zoomSpeed);
    this.radius = this.radius * zoomFactor;
    this.radius = Math.max(this.minRadius, Math.min(this.maxRadius, this.radius));
  }

  update() {
    const sinPhi = Math.sin(this.phi);
    const x = this.radius * sinPhi * Math.sin(this.theta);
    const y = this.radius * Math.cos(this.phi);
    const z = this.radius * sinPhi * Math.cos(this.theta);
    this.camera.position.set(this.target.x + x, this.target.y + y, this.target.z + z);
    this.camera.lookAt(this.target);
  }
}


function ensure3D() {
  if (g3d.inited) return;

  g3d.container = document.getElementById('vis3d');
  g3d.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
  g3d.renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  g3d.container.appendChild(g3d.renderer.domElement);

  g3d.scene = new THREE.Scene();

  g3d.camera = new THREE.PerspectiveCamera(45, 1, 0.01, 100);
  g3d.camera.position.set(2.6, 2.0, 2.6);
  g3d.camera.lookAt(0,0,0);

    g3d.controls = new SimpleOrbitControls(g3d.camera, g3d.renderer.domElement);
            g3d.controls.target.set(0,0,0);

  // Soft lighting
  g3d.scene.add(new THREE.AmbientLight(0xffffff, 0.85));
  const dir = new THREE.DirectionalLight(0xffffff, 0.55);
  dir.position.set(3,4,2);
  g3d.scene.add(dir);

  // Cube bounds [-1,1]^3
  const boxGeom = new THREE.BoxGeometry(2,2,2);
  const edges = new THREE.EdgesGeometry(boxGeom);
  g3d.scene.add(new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x222222 })));

  // Three “corner” planes (like the reference image)
  // XY plane at z=-1, XZ plane at y=-1, YZ plane at x=-1
  const gridColor = 0x9ec5ff;
  const gridDiv = 8;

  const gridXY = new THREE.GridHelper(2, gridDiv, gridColor, gridColor);
  gridXY.rotation.x = Math.PI/2;
  gridXY.position.z = -1;
  g3d.scene.add(gridXY);

  const gridXZ = new THREE.GridHelper(2, gridDiv, gridColor, gridColor);
  gridXZ.position.y = -1;
  g3d.scene.add(gridXZ);

  const gridYZ = new THREE.GridHelper(2, gridDiv, gridColor, gridColor);
  gridYZ.rotation.z = Math.PI/2;
  gridYZ.position.x = -1;
  g3d.scene.add(gridYZ);

  g3d.scene.add(new THREE.AxesHelper(1.2));

  // Point clouds (updated per run)
  g3d.votersPts = new THREE.Points(
    new THREE.BufferGeometry(),
    new THREE.PointsMaterial({ size: 0.03, sizeAttenuation: true, vertexColors: true, transparent: true, opacity: 0.75 })
  );
  g3d.scene.add(g3d.votersPts);

  g3d.candPts = new THREE.Points(
    new THREE.BufferGeometry(),
    new THREE.PointsMaterial({ size: 0.22, sizeAttenuation: true, vertexColors: true })
  );
  g3d.scene.add(g3d.candPts);

  g3d.inited = true;
  resize3D();
  start3DLoop();
}

function start3DLoop() {
  if (!g3d.inited) return;
  if (g3d.animHandle) return;

  const tick = () => {
    g3d.animHandle = requestAnimationFrame(tick);
    g3d.controls.update();
    g3d.renderer.render(g3d.scene, g3d.camera);
  };
  tick();
}

function stop3DLoop() {
  if (g3d.animHandle) {
    cancelAnimationFrame(g3d.animHandle);
    g3d.animHandle = 0;
  }
}

function resize3D() {
  if (!g3d.inited) return;
  const wrap = document.getElementById('vis3dWrap');
  const w = Math.max(1, wrap.clientWidth);
  const h = Math.max(1, wrap.clientHeight);
  g3d.renderer.setSize(w, h, false);
  g3d.camera.aspect = w / h;
  g3d.camera.updateProjectionMatrix();
}

function show3D(show) {
  const wrap2d = document.getElementById('canvasWrap');
  const wrap3d = document.getElementById('vis3dWrap');
  if (show) {
    wrap2d.style.display = 'none';
    wrap3d.style.display = 'block';
    ensure3D();
    resize3D();
    start3DLoop();
  } else {
    wrap3d.style.display = 'none';
    wrap2d.style.display = 'block';
    // Save battery/CPU on phones when 3D isn't visible.
    if (g3d.inited) stop3DLoop();
  }
}

window.addEventListener('resize', () => {
  resize3D();
});

function makeLabelSprite(text) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  const fontSize = 48;
  ctx.font = fontSize + 'px Arial';

  const padding = 16;
  const textWidth = ctx.measureText(text).width;

  canvas.width = textWidth + padding * 2;
  canvas.height = fontSize + padding * 2;

  // background
  ctx.fillStyle = 'rgba(255,255,255,0.85)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // text
  ctx.fillStyle = '#111';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = fontSize + 'px Arial';
  ctx.fillText(text, canvas.width / 2, canvas.height / 2);

  const texture = new THREE.CanvasTexture(canvas);
  const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
  const sprite = new THREE.Sprite(material);

  // world-size scaling (tuned for [-1,1] cube)
  sprite.scale.set(0.6, 0.25, 1);

  return sprite;
}

function set3DData(result) {
  ensure3D();
  const K = result.candidates.length;

  // Render performance note:
  // Plotting thousands of points in WebGL is fine, but plotting 10k+ with per-run allocations can feel slow on phones.
  // We downsample voters for rendering (simulation still uses full N) and avoid DOM/color parsing.

  const MAX_RENDER_VOTERS = 4000; // adjust: 2000-6000 is a good phone-friendly range

  function hslToRgb01(h, s, l) {
    // h in [0,360), s/l in [0,1] -> rgb in [0,1]
    h = ((h % 360) + 360) % 360;
    const c = (1 - Math.abs(2*l - 1)) * s;
    const hp = h / 60.0;
    const x = c * (1 - Math.abs((hp % 2) - 1));
    let r1=0,g1=0,b1=0;
    if (0 <= hp && hp < 1) { r1=c; g1=x; b1=0; }
    else if (1 <= hp && hp < 2) { r1=x; g1=c; b1=0; }
    else if (2 <= hp && hp < 3) { r1=0; g1=c; b1=x; }
    else if (3 <= hp && hp < 4) { r1=0; g1=x; b1=c; }
    else if (4 <= hp && hp < 5) { r1=x; g1=0; b1=c; }
    else { r1=c; g1=0; b1=x; }
    const m = l - c/2;
    return [r1+m, g1+m, b1+m];
  }

  // Candidate colors (match 1D/2D vibe), precomputed in RGB01 for WebGL
  const candRGB = [];
  for (let i=0;i<K;i++){
    const hue = (i*360/K) % 360;
    candRGB.push(hslToRgb01(hue, 0.70, 0.45));
  }

  // Voters (downsample for rendering)
  const votersAll = result.voters;
  const Nall = votersAll.length;
  const N = Math.min(Nall, MAX_RENDER_VOTERS);

  // Sample evenly (deterministic-ish) to keep density impression without heavy cost.
  const step = Math.max(1, Math.floor(Nall / N));

  const vpos = new Float32Array(N * 3);
  const vcol = new Float32Array(N * 3);

  let out = 0;
  for (let i=0; i<Nall && out < N; i += step) {
    const v = votersAll[i];
    vpos[3*out+0] = v.pos[0];
    vpos[3*out+1] = v.pos[1];
    vpos[3*out+2] = v.pos[2];

    const choice = v.plurality_choice;
    const rgb = (choice >= 0 && choice < K) ? candRGB[choice] : [0.5,0.5,0.5];
    vcol[3*out+0] = rgb[0];
    vcol[3*out+1] = rgb[1];
    vcol[3*out+2] = rgb[2];
    out++;
  }

  const vg = new THREE.BufferGeometry();
  vg.setAttribute('position', new THREE.BufferAttribute(vpos, 3));
  vg.setAttribute('color', new THREE.BufferAttribute(vcol, 3));
  g3d.votersPts.geometry.dispose();
  g3d.votersPts.geometry = vg;

  // Candidates
  const cpos = new Float32Array(K*3);
  const ccol = new Float32Array(K*3);
  for (let i=0;i<K;i++){
    cpos[3*i+0] = result.candidates[i][0];
    cpos[3*i+1] = result.candidates[i][1];
    cpos[3*i+2] = result.candidates[i][2];
    const rgb = candRGB[i];
    ccol[3*i+0] = rgb[0];
    ccol[3*i+1] = rgb[1];
    ccol[3*i+2] = rgb[2];
  }
  const cg = new THREE.BufferGeometry();
  cg.setAttribute('position', new THREE.BufferAttribute(cpos, 3));
  cg.setAttribute('color', new THREE.BufferAttribute(ccol, 3));
  g3d.candPts.geometry.dispose();
  g3d.candPts.geometry = cg;

  // ----- Candidate labels (C0, C1, ...) -----
  if (!g3d.candLabels) g3d.candLabels = [];

  // Remove extra labels if candidate count shrank
  while (g3d.candLabels.length > K) {
    const spr = g3d.candLabels.pop();
    g3d.scene.remove(spr);
    spr.material.map.dispose();
    spr.material.dispose();
  }

  // Add missing labels
  while (g3d.candLabels.length < K) {
    const idx = g3d.candLabels.length;
    const spr = makeLabelSprite('C' + idx);
    g3d.candLabels.push(spr);
    g3d.scene.add(spr);
  }

  // Position labels near candidates
  for (let i = 0; i < K; i++) {
    const spr = g3d.candLabels[i];
    const c = result.candidates[i];

    spr.position.set(c[0], c[1], c[2]);
    spr.position.add(new THREE.Vector3(0.12, 0.12, 0.12)); // offset so it doesn't overlap the dot
  }

    g3d.controls.target.set(0,0,0);
    g3d.controls.update();
  }


  function draw1D(result) {
   const w = document.getElementById('canvasWrap').clientWidth;
   const h = document.getElementById('canvasWrap').clientHeight;

   // Safe padding so labels never clip on small screens
   const padTop = 18;
   const padBottom = 46;   // room for tick labels
   const left = 34;
   const right = 18;

   // Place axis inside the safe area (not too low)
   const axisY = Math.round(padTop + (h - padTop - padBottom) * 0.55);
    
   ctx.textBaseline = 'top';
   ctx.fillText(String(t), px, Math.min(axisY + 10, h - padBottom + 6));
    
   //voter jitter visual fix
   const jitter = (Math.random() - 0.5) * 18;
   let py = axisY + jitter;
   py = Math.max(padTop + 6, Math.min(h - padBottom - 6, py));

   ctx.clearRect(0,0,w,h);

   // axis
   ctx.strokeStyle = '#222';
   ctx.lineWidth = 2;
   ctx.beginPath();
   const y = h/2;
   ctx.moveTo(20,y);
   ctx.lineTo(w-20,y);
   ctx.stroke();

   const dim = result.cfg.d;
   const K = result.candidates.length;

  // candidate colors
   const colors = [];
   for (let i=0;i<K;i++){
     const hue = Math.floor((i*360/K) % 360);
     colors.push(`hsl(${hue} 70% 45%)`);
  }

  // helper to map x (-1..1) to px
  function mapX(x) {
    return 20 + ((x + 1) / 2) * (w - 40);
  }

  // draw voters as small dots, colored by plurality choice
  const voters = result.voters;
  // optional jitter in y so dots don't fully overlap
  for (const v of voters) {
    if (dim !== 1) continue;
    const px = mapX(v.pos[0]);
    const jitter = (Math.random()-0.5) * 18;
    const py = y + jitter;
    const choice = v.plurality_choice;
    ctx.beginPath();
    ctx.fillStyle = (choice >= 0) ? colors[choice] : '#888';
    ctx.globalAlpha = 0.85;
    ctx.arc(px, py, 2.0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1.0;
  }

  // draw candidates as ticks + labels
  ctx.font = '12px Arial';
  ctx.textAlign = 'center';
  for (let i=0;i<K;i++){
    const c = result.candidates[i];
    const px = mapX(c[0]);
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(px, y-12);
    ctx.lineTo(px, y+12);
    ctx.stroke();
    // label above
    ctx.fillStyle = colors[i];
    ctx.fillText('C'+i, px, y-18);
    // marker circle
    ctx.beginPath();
    ctx.fillStyle = colors[i];
    ctx.arc(px, y, 6, 0, Math.PI*2);
    ctx.fill();
  }

  // summary
  qs('log').textContent = `Dimension=${dim}, Voters=${result.cfg.v}, Candidates=${K}, Layout=${result.cfg.l}
Plurality winner: ${result.plurality.winner} (tie=${result.plurality.tie}), avg util=${result.plurality.avgUtilOverall.toFixed(4)}
Approval winner: ${result.approval.winner} (tie=${result.approval.tie}), turnout=${result.approval.turnout}, avg util=${result.approval.avgUtilOverall.toFixed(4)}`;
}

function draw2D(result) {
  const w = document.getElementById('canvasWrap').clientWidth;
  const h = document.getElementById('canvasWrap').clientHeight;
  ctx.clearRect(0,0,w,h);
  const dim = result.cfg.d;
  if (dim < 2) { ctx.fillStyle='#000'; ctx.fillText('2D view requires dim=2', 20,20); return; }

  ctx.fillStyle = 'rgba(158,197,255,0.10)'; // same vibe as 3D
  ctx.fillRect(boxL, boxT, boxR - boxL, boxB - boxT);

  // map [-1,1] to margin..w-margin
  const margin = 18;
  function mapX(x){ return margin + ((x+1)/2) * (w - 2*margin); }
  function mapY(y){ return margin + ((1 - (y+1)/2)) * (h - 2*margin); } // invert Y

  const K = result.candidates.length;
  const colors = [];
  for (let i=0;i<K;i++){
    const hue = Math.floor((i*360/K) % 360);
    colors.push(`hsl(${hue} 70% 45%)`);
  }
  
  // Axis lines for x=0 and y=0
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 2;

  // x=0 vertical axis
  const x0 = mapX(0);
  ctx.beginPath();
  ctx.moveTo(x0, boxT);
  ctx.lineTo(x0, boxB);
  ctx.stroke();

  // y=0 horizontal axis
  const y0 = mapY(0);
  ctx.beginPath();
  ctx.moveTo(boxL, y0);
  ctx.lineTo(boxR, y0);
  ctx.stroke();

  ctx.fillStyle = '#222';
  ctx.font = '12px Arial';

  // x arrow
  ctx.beginPath();
  ctx.moveTo(boxR, y0);
  ctx.lineTo(boxR - 10, y0 - 4);
  ctx.lineTo(boxR - 10, y0 + 4);
  ctx.closePath();
  ctx.fill();
  ctx.fillText('x', boxR - 12, y0 - 10);

  // y arrow
  ctx.beginPath();
  ctx.moveTo(x0, boxT);
  ctx.lineTo(x0 - 4, boxT + 10);
  ctx.lineTo(x0 + 4, boxT + 10);
  ctx.closePath();
  ctx.fill();
  ctx.fillText('y', x0 + 10, boxT + 14);
  
  
    // voters
  for (const v of result.voters) {
    const px = mapX(v.pos[0]), py = mapY(v.pos[1]);
    const choice = v.plurality_choice;
    ctx.beginPath();
    ctx.fillStyle = (choice>=0) ? colors[choice] : '#888';
    ctx.globalAlpha = 0.8;
    ctx.arc(px, py, 2.0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1.0;
  }

  // candidates
  ctx.font = '12px Arial';
  ctx.textAlign = 'center';
  for (let i=0;i<K;i++){
    const c = result.candidates[i];
    const px = mapX(c[0]), py = mapY(c[1]);
    ctx.beginPath();
    ctx.fillStyle = colors[i];
    ctx.arc(px, py, 6.0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#000';
    ctx.fillText('C'+i, px, py-10);
  }

  qs('log').textContent = `2D: Dim=${dim}, voters=${result.cfg.v}, candidates=${K}
Plurality winner: ${result.plurality.winner} (tie=${result.plurality.tie}), avg util=${result.plurality.avgUtilOverall.toFixed(4)}
Approval winner: ${result.approval.winner} (tie=${result.approval.tie}), turnout=${result.approval.turnout}, avg util=${result.approval.avgUtilOverall.toFixed(4)}`;
}


// --- 3D visualization: corner axes with 3 grid planes (xyz corner) ---
// We use a simple affine "corner projection":
//  - Map x,y,z in [-1,1] to u,v,w in [0,1]
//  - Project: P = origin + u*vx + v*vy + w*vz
// This produces a clean corner/cube view with three visible planes.
// We also clip points to the convex hull of the projected cube so scatter stays inside.

function projCorner(u, v, w, origin, vx, vy, vz) {
  return [
    origin[0] + u*vx[0] + v*vy[0] + w*vz[0],
    origin[1] + u*vx[1] + v*vy[1] + w*vz[1]
  ];
}

// 2D cross product of OA x OB
function cross2(o, a, b) {
  return (a[0]-o[0])*(b[1]-o[1]) - (a[1]-o[1])*(b[0]-o[0]);
}

// Monotonic chain convex hull (returns hull points in CCW order, no duplicate last point)
function convexHull(points) {
  if (points.length <= 1) return points.slice();
  const pts = points.slice().sort((p,q)=> (p[0]===q[0]) ? (p[1]-q[1]) : (p[0]-q[0]));
  const lower = [];
  for (const p of pts) {
    while (lower.length >= 2 && cross2(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop();
    lower.push(p);
  }
  const upper = [];
  for (let i=pts.length-1;i>=0;i--) {
    const p = pts[i];
    while (upper.length >= 2 && cross2(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop();
    upper.push(p);
  }
  upper.pop();
  lower.pop();
  return lower.concat(upper);
}

function drawGridOnPlane(A, B, C, D, steps, lineColor) {
  // Draw a grid inside the quad ABCD by interpolating between edges.
  ctx.strokeStyle = lineColor;
  ctx.lineWidth = 1;

  for (let i=0;i<=steps;i++) {
    const t = i/steps;

    // lines parallel to AB-CD
    const p1 = [A[0] + t*(B[0]-A[0]), A[1] + t*(B[1]-A[1])];
    const p2 = [D[0] + t*(C[0]-D[0]), D[1] + t*(C[1]-D[1])];
    ctx.beginPath();
    ctx.moveTo(p1[0], p1[1]);
    ctx.lineTo(p2[0], p2[1]);
    ctx.stroke();

    // lines parallel to AD-BC
    const q1 = [A[0] + t*(D[0]-A[0]), A[1] + t*(D[1]-A[1])];
    const q2 = [B[0] + t*(C[0]-B[0]), B[1] + t*(C[1]-B[1])];
    ctx.beginPath();
    ctx.moveTo(q1[0], q1[1]);
    ctx.lineTo(q2[0], q2[1]);
    ctx.stroke();
  }
}

function draw3D(result) {
  if (typeof THREE === 'undefined') {
    show3D(false);
    qs('log').textContent = '3D unavailable: Three.js failed to load. Try reloading, or host online (GitHub Pages). Falling back to 2D projection.';
    draw2D(result);
    return;
  }
  show3D(true);
  set3DData(result);
const K = result.candidates.length;
  qs('log').textContent =
`3D interactive view: drag to rotate, pinch/scroll to zoom.
voters=${result.cfg.v}, candidates=${K}
Plurality winner: ${result.plurality.winner} (tie=${result.plurality.tie}), avg util=${result.plurality.avgUtilOverall.toFixed(4)}
Approval winner: ${result.approval.winner} (tie=${result.approval.tie}), turnout=${result.approval.turnout}, avg util=${result.approval.avgUtilOverall.toFixed(4)}`;
}

function drawResult(result) {
  if (result.cfg.d === 1) { show3D(false); draw1D(result); }
  else if (result.cfg.d === 2) { show3D(false); draw2D(result); }
  else { draw3D(result); }
}




// UI handlers
function readControls() {
  const d = parseInt(qs('dim').value);
  const v = Math.max(1, Math.min(10000, parseInt(qs('voters').value) || 500));
  const k = Math.max(1, parseInt(qs('candidates').value) || 5);
  const l = qs('layout').value;
  const min = parseFloat(qs('mincand').value) || 0.3;
  const s = parseFloat(qs('noise').value) || 0.0;
  const m = qs('method').value;
  return { d, v, k, l, min, s, m };
}

function writeShareUrl(cfg) {
  const base = window.location.origin + window.location.pathname;
  const json = JSON.stringify({ d:cfg.d, v:cfg.v, k:cfg.k, l:cfg.l, min:cfg.min, s:cfg.s, m:cfg.m });
  const enc = base64urlEncode(json);
  const url = base + '?c=' + enc;
  qs('shareUrl').value = url;
  // QR update
  const qr = new QRious({ element: qs('qr'), value: url, size:128 });
}

qs('encodeBtn').addEventListener('click', ()=> {
  const cfg = readControls();
  writeShareUrl(cfg);
});

qs('runBtn').addEventListener('click', ()=> {
  const cfg = readControls();
  qs('log').textContent = 'Running...';
  // Yield once so the browser paints 'Running...' before heavy work
  requestAnimationFrame(()=> {
    try {
 // let UI update
      const result = runSimulation(cfg);
      drawResult(result);
      // save last result for CSV download
      window._lastResult = result;
    } catch (e) {
      qs('log').textContent = 'Error: ' + (e && e.message ? e.message : String(e));
      console.error(e);
    }
  });
});

qs('downloadCsvBtn').addEventListener('click', ()=> {
  const r = window._lastResult;
  if (!r) { alert('Run a simulation first'); return; }
  const csv = makeCsvForRun(r);
  const blob = new Blob([csv], { type:'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'run_voters_' + nowStamp() + '.csv';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
});

// On load: if ?c= present, decode and populate form automatically and generate QR
function populateFromUrl() {
  const params = new URLSearchParams(window.location.search);
  if (params.has('c')) {
    const dec = base64urlDecode(params.get('c'));
    if (dec) {
      try {
        const obj = JSON.parse(dec);
        if (typeof obj.d === 'number') qs('dim').value = obj.d;
        if (typeof obj.v === 'number') qs('voters').value = obj.v;
        if (typeof obj.k === 'number') qs('candidates').value = obj.k;
        if (typeof obj.l === 'string') qs('layout').value = obj.l;
        if (typeof obj.min === 'number') qs('mincand').value = obj.min;
        if (typeof obj.s === 'number') qs('noise').value = obj.s;
        if (typeof obj.m === 'string') qs('method').value = obj.m;
        writeShareUrl(readControls());
        qs('log').textContent = 'Config loaded from URL.';
      } catch(e) { qs('log').textContent = 'Failed to parse config from URL.'; }
    } else qs('log').textContent = 'Failed to decode config (base64).';
  }
}

window.addEventListener('load', ()=> {
  populateFromUrl();
  resize2DCanvas();
  // Diagnostics: helps when 3D is stuck due to missing WebGL/Three.js.
  const hasThree = (typeof THREE !== 'undefined');
  const hasWebGL = (()=> {
    try {
      const c = document.createElement('canvas');
      return !!(window.WebGLRenderingContext && (c.getContext('webgl') || c.getContext('experimental-webgl')));
    } catch(e) { return false; }
  })();

  if (!hasThree) {
    console.warn('Three.js not loaded (CDN blocked/offline). 3D view will fail.');
  }
  if (!hasWebGL) {
    console.warn('WebGL not available in this browser/device. 3D view will fail.');
  }

  // Show a helpful note in the UI (non-fatal)
  if (!hasThree || !hasWebGL) {
    const notes = [];
    if (!hasThree) notes.push('Three.js not loaded (CDN blocked/offline).');
    if (!hasWebGL) notes.push('WebGL not available.');
    notes.push('If dim=3 appears stuck, open DevTools Console for details.');
    qs('log').textContent = 'Ready. Note: ' + notes.join(' ');
  }
});</script>
</body>
</html>
